```
1. Какой системный вызов делает команда cd? В прошлом ДЗ мы выяснили,
что cd не является самостоятельной программой, это shell builtin, поэтому запустить strace непосредственно на cd не получится.
Тем не менее, вы можете запустить strace на /bin/bash -c 'cd /tmp'. В этом случае вы увидите полный список системных вызовов,
которые делает сам bash при старте. Вам нужно найти тот единственный, который относится именно к cd.
Обратите внимание, что strace выдаёт результат своей работы в поток stderr, а не в stdout.
```
Системный вызов команды cd:  
![Скриншот](https://github.com/aleksey-raevich/devops-netology/blob/master/Lab3.3/Screenshot1.png)

```
2. Попробуйте использовать команду file на объекты разных типов на файловой системе. Например:
vagrant@netology1:~$ file /dev/tty
/dev/tty: character special (5/0)
vagrant@netology1:~$ file /dev/sda
/dev/sda: block special (8/0)
vagrant@netology1:~$ file /bin/bash
/bin/bash: ELF 64-bit LSB shared object, x86-64
Используя strace выясните, где находится база данных file на основании которой она делает свои догадки.
```

База данных file находится: /usr/share/misc/magic.mgc
openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3

```
3. Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof),
однако возможности сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет.
Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается.
Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла
(чтобы освободить место на файловой системе).
```
* Создал в vim файл, записал и оставил открытым на редактировании
* vagrant@vagrant:~/testdir$ lsof | grep test
vim       11057   vagrant    4u      REG   253,0    12288     524319 /home/vagrant/testdir/.test.swp  
* удалил файл
vim       11057   vagrant    4u      REG   253,0    12288     524319 /home/vagrant/testdir/.test.swp (deleted)  
* vagrant@vagrant:~/testdir$ ll /proc/11057/fd/
...  
lrwx------ 1 vagrant vagrant 64 Aug 16 08:55 4 -> '/home/vagrant/testdir/.test.swp (deleted)'  
* переписываем файл
vagrant@vagrant:~/testdir$ echo '' >/proc/11057/fd/4  

```
4. Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?
```
Зомби - это процесс, который имеет только запись в таблице процессов,  
никакие ресурсы кроме пространства таблицы процессов, не используются.
Процесс-сирота - когда родительский процесс завершается раньше дочернего, 
остается активен и выполняется в отличие от зомби процесса.
Зомби процесс контролируется родительским процессом,  
когда родительский процесс завершается, то и зомби-процесс завершается.

```
5. В iovisor BCC есть утилита opensnoop:
root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop
/usr/sbin/opensnoop-bpfcc
На какие файлы вы увидели вызовы группы open за первую секунду работы утилиты?
Воспользуйтесь пакетом bpfcc-tools для Ubuntu 20.04.
Дополнительные сведения по установке.
```
Для использования пришлось установить в CenOs7:  
* yum install kernel-headers
* yum install kernel-devel-$(uname -r)

./opensnoop
PID    COMM               FD ERR PATH
16648  cadvisor            7   0 /rootfs/sys/fs/cgroup/cpu,cpuacct/system.slice/cpu.stat
16648  cadvisor            7   0 /rootfs/sys/fs/cgroup/cpu,cpuacct/system.slice/cpuacct.stat
16648  cadvisor            7   0 /rootfs/sys/fs/cgroup/cpu,cpuacct/system.slice/cpuacct.usage
16648  cadvisor            7   0 /rootfs/sys/fs/cgroup/cpu,cpuacct/system.slice/cpuacct.usage_percpu
16648  cadvisor            7   0 /rootfs/sys/fs/cgroup/memory/system.slice/memory.stat
...


```
6. Какой системный вызов использует uname -a?
Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в /proc,
где можно узнать версию ядра и релиз ОС.
```
* вызов uname()
* из man:
   2228        /proc/sys/kernel/ostype and /proc/sys/kernel/osrelease  
   2229               These files give substrings of /proc/version.
```
7. Чем отличается последовательность команд через ; и через && в bash? Например:
root@netology1:~# test -d /tmp/some_dir; echo Hi
Hi
root@netology1:~# test -d /tmp/some_dir && echo Hi
root@netology1:~#
Есть ли смысл использовать в bash &&, если применить set -e?
```
* Оператор ; позволяет запускать несколько команд за один раз, и выполнение команды происходит последовательно.
* Оператор AND (&&) будет выполнять вторую команду только в том случае, если при выполнении первой команды SUCCEEDS,
т.е. состояние выхода первой команды равно «0» — программа выполнена успешно.
* set -e - незамедлительный выход, если любая из команд имеет ненулевой код возврата
Т.е. использовать set -e вместе с && не имеет смысла

```
8. Из каких опций состоит режим bash set -euxo pipefail и почему его хорошо было бы использовать в сценариях?
```
* e - незамедлительный выход, если любая из команд последовательности имеет ненулевой код возврата
* x - режим отладки
* u - переменные и параметры ранее не заданные являются ошибками
* o - параметр предотвращает маскирование ошибок в пайпе.
В случае сбоя какой-либо команды в пайпе этот код возврата будет использоваться как код возврата для всего пайпа.  
* Полезно использовать для повышения детализации (логирования), завершения сценария при наличии ошибок.

```
9. Используя -o stat для ps, определите, какой наиболее часто встречающийся статус у процессов в системе.
В man ps ознакомьтесь (/PROCESS STATE CODES) что значат дополнительные к основной заглавной буквы статуса процессов.
Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными).
```
Самые частые статусы:
* S - процессы в неактивном состоянии, ожидают выполнения или спят
* R - процесс выполняется в данный момент
* доп.символы - это специальные флаги, например, приоритет