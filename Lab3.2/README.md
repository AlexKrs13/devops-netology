### Lab3.2 Terminal

```
1. Какого типа команда cd?
Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей,
если считаете что она могла бы быть другого типа.
```
cd - это встроенная в оболочку bash команда, ее нет в каталоге /bin  
Т.е. это команда, которая вызывается из оболочки и выполняется непосредственно в самой оболочке.  
Оболочка Bash выполняет команду напрямую, без вызова других программ.  

Список всех встроенных в оболочку команд можно посмотреть: help | less

```
2. Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l? man grep поможет в ответе на этот вопрос.
Ознакомьтесь с документом о других подобных некорректных вариантах использования pipe.
```

```
vagrant@vagrant:~/testdir$ cat input.txt
_line1
_line2
_line3
vagrant@vagrant:~/testdir$ grep line1  input.txt -c
1
vagrant@vagrant:~/testdir$ grep line1 input.txt | wc -l
1
```

```
3. Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?
```
Это systemd:  
![Скриншот](https://github.com/aleksey-raevich/devops-netology/blob/master/Lab3.2/Screenshot3.png)

```
4. Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?
```

```
В первом терминале:  
vagrant@vagrant:/bin$ tty  
/dev/pts/0  
vagrant@vagrant:/bin$ ls -alh \bin 2>/dev/pts/1  

Во втором терминале:  
vagrant@vagrant:~$ tty  
/dev/pts/1  
vagrant@vagrant:~$ ls: cannot access 'bin': No such file or directory  
```

```
5. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл?
Приведите работающий пример.
```

```
vagrant@vagrant:~/testdir$ cat input.txt  
_line1  
_line2  
_line3  
vagrant@vagrant:~/testdir$ ll
drwxrwxr-x 2 vagrant vagrant 2867200 Aug  9 05:44 ./
drwxr-xr-x 5 vagrant vagrant    4096 Aug  9 05:43 ../
-rw-rw-r-- 1 vagrant vagrant      21 Aug  9 05:43 input.txt
vagrant@vagrant:~/testdir$ cat 0<input.txt 1>output.txt
vagrant@vagrant:~/testdir$ cat output.txt
_line1
_line2
_line3
```

```
6. Получится ли находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY?
Сможете ли вы наблюдать выводимые данные?
```
![Скриншот](https://github.com/aleksey-raevich/devops-netology/blob/master/Lab3.2/Screenshot6.png)

```
7. Выполните команду bash 5>&1. К чему она приведет?
Что будет, если вы выполните echo netology > /proc/$$/fd/5? Почему так происходит?
```

```
bash 5>&1 - создение дескриптора и перенаправление в stdout
echo netology > /proc/$$/fd/5 - вывод в декскриптор 5 сообщения netology
```

```
8. Получится ли в качестве входного потока для pipe использовать только stderr команды,
не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды
слева от | на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный новый
дескриптор, который вы научились создавать в предыдущем вопросе.
```

```
vagrant@vagrant:~/testdir$ ls -alh /root 4>&2 2>&1 1>&4 | grep Permission -c
1

4>&2 - создаем новый дескриптор и перенаправляем в sdterr
2>&1 - stdrerr перенаправляем в stdout
1>&4 - stdout перенаправляем в созданный дескриптор
```

```
9. Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод?
```
cat /proc/$$/environ - вывод переменных окружения  
в качестве основной альтернативы используются printenv и env  

```
10. Используя man, опишите что доступно по адресам /proc/<PID>/cmdline, /proc/<PID>/exe
```
170        /proc/[pid]/cmdline
Полная командная строка для процесса PID, если он не является зомби процессом

210        /proc/[pid]/exe
Представляет собой символическую ссылку, содержащую фактический путь к файлу, запущенному для процесса PID

```
11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo
# grep sse /proc/cpuinfo
```
sse4_2  

```
12. При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty.
Это можно подтвердить командой tty, которая упоминалась в лекции 3.2. Однако:
vagrant@netology1:~$ ssh localhost 'tty'
not a tty
Почитайте, почему так происходит, и как изменить поведение.
```
Нашел в гугле:  
По умолчанию, когда вы запускаете команду на удаленном компьютере с помощью ssh,
для удаленного сеанса не выделяется TTY. Это позволяет вам передавать двоичные данные и т.д.  
Однако, когда вы запускаете ssh без удаленной команды, 
он выделяет TTY, потому что вы, вероятно, будете запускать сеанс оболочки.  
Нужно добавить флаг -t:  
$ ssh -t localhost 'tty'  
vagrant@localhost's password:  
/dev/pts/1  
Connection to localhost closed.  

```
13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую.
Попробуйте сделать это, воспользовавшись reptyr. Например, так можно перенести в screen процесс,
который вы запустили по ошибке в обычной SSH-сессии.
```
К сожалению поставить reptyr на arm архитектуре так и не смог:  
dpkg: reptyr:amd64: dependency problems, but configuring anyway as you requested:  
 reptyr:amd64 depends on libc6 (>= 2.15)  
libc6 собрать под arm никак нельзя( или не хватило опыта

Выполнил задание на рабочем сервере на CentOs7:
* Устанавливаем epel-release rpm  
```# yum install epel-release```
* Устанавливаем reptyr rpm package  
```# yum install reptyr```
* Устанавливаем screen
```# yum install screen```
* Запускаем долгий процесс - top
* Нажимаем Ctrl+Z, чтобы перевести процесс в фоновый режим  
```[1]+  Stopped                 top```
* Вводим команду bg для возобновления процесса в фоновом режиме  
```
[1]+ top &

[1]+  Stopped                 top
```
* Проверяем запущенные фоновые задания  
```
# jobs -l
[1]+ 77444 Stopped (signal)        top
```
* Отвязываем процесс от текущего родителя 
```
# disown top
-bash: warning: deleting stopped job 1 with process group 77444
```
* Проверяем, что процесс запущен
```
# ps -a
   PID TTY          TIME CMD
  9302 pts/0    00:00:00 mc
 68625 pts/1    00:00:00 vi
 77444 pts/3    00:00:00 top
 91688 pts/3    00:00:00 ps
```
* Запускаем screen и присоединяем фоновый процесс top
```
# screen
# reptyr 77444
```
* Выполняем detach screen session: Ctrl+d
* Проверяем список сессий screen: # screen -list
* Открываем новую ssh сессию, делаем reattach screen: # screen -r
* Закрываем первый терминал - top в скрине продолжает работать

```
14. sudo echo string > /root/new_file не даст выполнить перенаправление под обычным пользователем,
так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем.
Для решения данной проблемы можно использовать конструкцию echo string | sudo tee /root/new_file.
Узнайте что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.
```
Команда tee используется как соединитель (тройник) в цепочке конвейеров.
Tee считывает стандартный ввод (stdin), полученный через pipe от стандартного вывода (stdout) команды echo, выводит его одновременно в стандартный вывод (stdout) и в подготовленный файл.
Права sudo позволяют tee создавать и записывать файл в домашнем каталоге root пользователя.
